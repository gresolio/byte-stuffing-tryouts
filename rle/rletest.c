#include "rle.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define ARRAY_LENGTH(x) (sizeof(x) / sizeof((x)[0]))

enum test_type
{
    ENCODE = 0,
    DECODE = 1
};

typedef struct
{
    const uint8_t* data_ptr;
    size_t data_len;
} data_info;

// Single byte value
static const uint8_t rawdata_0[] = { 0xAA };
static const uint8_t encoded_0[] = { 0x00, 0xAA };

// 1 copy
static const uint8_t rawdata_1[] = { 0xAA, 0xBB, 0xCC };
static const uint8_t encoded_1[] = { 0x02, 0xAA, 0xBB, 0xCC };

// 1 run
static const uint8_t rawdata_2[] = { 0xAA, 0xAA, 0xAA };
static const uint8_t encoded_2[] = { 0xFE, 0xAA };

// 3 runs
static const uint8_t rawdata_3[] = { 0xAA, 0xAA, 0xBB, 0xBB, 0xCC, 0xCC };
static const uint8_t encoded_3[] = { 0xFF, 0xAA, 0xFF, 0xBB, 0xFF, 0xCC };

// Copy, run
static const uint8_t rawdata_4[] = { 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC };
static const uint8_t encoded_4[] = { 0x00, 0xFF, 0xF7, 0xCC };

// Run, copy
static const uint8_t rawdata_5[] = { 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF };
static const uint8_t encoded_5[] = { 0xF7, 0xCC, 0x00, 0xFF };

// Copy, run, copy
static const uint8_t rawdata_6[] = { 0xAA, 0xBB, 0xCC, 0xDD, 0xDD, 0xDD, 0xDD, 0xDD, 0xEE, 0xFF };
static const uint8_t encoded_6[] = { 0x02, 0xAA, 0xBB, 0xCC, 0xFC, 0xDD, 0x01, 0xEE, 0xFF };

// Run, copy, run, copy, run
static const uint8_t rawdata_7[] = { 0xAA, 0xAA, 0xAA, 0x80, 0x00, 0x2A, 0xAA, 0xAA, 0xAA, 0xAA, 0x80, 0x00, 0x2A, 0x22, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
static const uint8_t encoded_7[] = { 0xFE, 0xAA, 0x02, 0x80, 0x00, 0x2A, 0xFD, 0xAA, 0x03, 0x80, 0x00, 0x2A, 0x22, 0xF7, 0xAA };

// 130 0xAA to test MAX_RUN 129
static const uint8_t rawdata_8[] = { 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA };
static const uint8_t encoded_8[] = { 0x80, 0xAA, 0x00, 0xAA };

// 129 alternating values to test MAX_COPY 128
static const uint8_t rawdata_9[] = { 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xCC };
static const uint8_t encoded_9[] = { 0x7F, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0xAA, 0xBB, 0x00, 0xCC };

static const data_info test_data_raw[] = {
    { rawdata_0, sizeof(rawdata_0) },
    { rawdata_1, sizeof(rawdata_1) },
    { rawdata_2, sizeof(rawdata_2) },
    { rawdata_3, sizeof(rawdata_3) },
    { rawdata_4, sizeof(rawdata_4) },
    { rawdata_5, sizeof(rawdata_5) },
    { rawdata_6, sizeof(rawdata_6) },
    { rawdata_7, sizeof(rawdata_7) },
    { rawdata_8, sizeof(rawdata_8) },
    { rawdata_9, sizeof(rawdata_9) },
};

static const data_info test_data_encoded[] = {
    { encoded_0, sizeof(encoded_0) },
    { encoded_1, sizeof(encoded_1) },
    { encoded_2, sizeof(encoded_2) },
    { encoded_3, sizeof(encoded_3) },
    { encoded_4, sizeof(encoded_4) },
    { encoded_5, sizeof(encoded_5) },
    { encoded_6, sizeof(encoded_6) },
    { encoded_7, sizeof(encoded_7) },
    { encoded_8, sizeof(encoded_8) },
    { encoded_9, sizeof(encoded_9) },
};

void print_hex(const char* prefix, const uint8_t* src_ptr, size_t src_len)
{
    printf("%s[%zu]: ", prefix, src_len);

    if (src_len > 50) {
        // Reduced output
        for (size_t i = 0; i < 20; i++)
            printf("%02X ", src_ptr[i]);
        printf("... ");
        for (size_t i = src_len - 20; i < src_len; i++)
            printf("%02X ", src_ptr[i]);
    } else {
        // Full output
        for (size_t i = 0; i < src_len; i++)
            printf("%02X ", src_ptr[i]);
    }

    printf("\n");
}

int compare(const uint8_t* a, size_t a_len, const uint8_t* b, size_t b_len)
{
    if (a == NULL || b == NULL)
        return -1;

    if (a_len != b_len)
        return -2;

    for (size_t i = 0; i < a_len; i++)
        if (a[i] != b[i])
            return -3;

    return 0;
}

int verify(const uint8_t* write_buffer, const rle_result* result, const data_info* input, const data_info* output)
{
    print_hex("IN ", input->data_ptr, input->data_len);
    print_hex("OUT", write_buffer, result->out_len);

    if (0 != compare(write_buffer, result->out_len, output->data_ptr, output->data_len)) {
        print_hex("!!!", output->data_ptr, output->data_len);
        printf("out_len %zu, status %02X\n", result->out_len, result->status);
        printf("FAILED\n\n");
        return 0;
    } else {
        printf("OK\n\n");
        return 1;
    }
}

void run_tests(enum test_type test_type)
{
    int total = ARRAY_LENGTH(test_data_raw);
    int passed = 0;

    rle_result (*test_func)(void*, size_t, const void*, size_t);
    uint8_t write_buffer[1024];
    rle_result result;

    const data_info* input;
    const data_info* output;

    if (test_type == ENCODE) {
        printf("+--------+\n");
        printf("| Encode |\n");
        printf("+--------+\n");
        input = test_data_raw;
        output = test_data_encoded;
        test_func = &rle_encode;
    } else {
        printf("+--------+\n");
        printf("| Decode |\n");
        printf("+--------+\n");
        input = test_data_encoded;
        output = test_data_raw;
        test_func = &rle_decode;
    }

    for (int i = 0; i < total; i++) {
        memset(write_buffer, 'A', sizeof(write_buffer));
        result = test_func(write_buffer, sizeof(write_buffer), input[i].data_ptr, input[i].data_len);
        passed += verify(write_buffer, &result, &input[i], &output[i]);
    }

    printf("%d/%d PASSED\n\n", passed, total);
}

int main()
{
    if (ARRAY_LENGTH(test_data_raw) != ARRAY_LENGTH(test_data_encoded)) {
        printf("The length of the test data arrays does not match.\n");
        return -1;
    }

    run_tests(ENCODE);
    run_tests(DECODE);
    return 0;
}
